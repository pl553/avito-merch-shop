// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCoins = `-- name: AddCoins :execrows
UPDATE users
SET coins = coins + $1
WHERE username = $2
`

type AddCoinsParams struct {
	Coins    int32
	Username string
}

func (q *Queries) AddCoins(ctx context.Context, arg AddCoinsParams) (int64, error) {
	result, err := q.db.Exec(ctx, addCoins, arg.Coins, arg.Username)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchases (username, item, price)
VALUES ($1, $2, $3)
RETURNING id, username, item, price, created_at
`

type CreatePurchaseParams struct {
	Username string
	Item     string
	Price    int32
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, createPurchase, arg.Username, arg.Item, arg.Price)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Item,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, password_hash)
VALUES ($1, $2)
`

type CreateUserParams struct {
	Username     string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.Username, arg.PasswordHash)
	return err
}

const deductCoins = `-- name: DeductCoins :execrows
UPDATE users
SET coins = coins - $1
WHERE username = $2 AND coins >= $1
`

type DeductCoinsParams struct {
	Coins    int32
	Username string
}

func (q *Queries) DeductCoins(ctx context.Context, arg DeductCoinsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deductCoins, arg.Coins, arg.Username)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getCoinHistoryReceived = `-- name: GetCoinHistoryReceived :many
SELECT from_username, amount, created_at
FROM coin_transfers
WHERE to_username = $1
ORDER BY created_at
`

type GetCoinHistoryReceivedRow struct {
	FromUsername string
	Amount       int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetCoinHistoryReceived(ctx context.Context, toUsername string) ([]GetCoinHistoryReceivedRow, error) {
	rows, err := q.db.Query(ctx, getCoinHistoryReceived, toUsername)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoinHistoryReceivedRow
	for rows.Next() {
		var i GetCoinHistoryReceivedRow
		if err := rows.Scan(&i.FromUsername, &i.Amount, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinHistorySent = `-- name: GetCoinHistorySent :many
SELECT to_username, amount
FROM coin_transfers
WHERE from_username = $1
`

type GetCoinHistorySentRow struct {
	ToUsername string
	Amount     int32
}

func (q *Queries) GetCoinHistorySent(ctx context.Context, fromUsername string) ([]GetCoinHistorySentRow, error) {
	rows, err := q.db.Query(ctx, getCoinHistorySent, fromUsername)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoinHistorySentRow
	for rows.Next() {
		var i GetCoinHistorySentRow
		if err := rows.Scan(&i.ToUsername, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductPrice = `-- name: GetProductPrice :one
SELECT price
FROM products
WHERE item = $1
`

func (q *Queries) GetProductPrice(ctx context.Context, item string) (int32, error) {
	row := q.db.QueryRow(ctx, getProductPrice, item)
	var price int32
	err := row.Scan(&price)
	return price, err
}

const getUser = `-- name: GetUser :one
SELECT username, password_hash, coins
FROM users
WHERE username = $1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, username)
	var i User
	err := row.Scan(&i.Username, &i.PasswordHash, &i.Coins)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT username, password_hash, coins
FROM users
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(&i.Username, &i.PasswordHash, &i.Coins)
	return i, err
}

const insertCoinTransfer = `-- name: InsertCoinTransfer :exec
INSERT INTO coin_transfers (from_username, to_username, amount)
VALUES ($1, $2, $3)
`

type InsertCoinTransferParams struct {
	FromUsername string
	ToUsername   string
	Amount       int32
}

func (q *Queries) InsertCoinTransfer(ctx context.Context, arg InsertCoinTransferParams) error {
	_, err := q.db.Exec(ctx, insertCoinTransfer, arg.FromUsername, arg.ToUsername, arg.Amount)
	return err
}

const listInventory = `-- name: ListInventory :many
SELECT item, COUNT(*) AS quantity
FROM purchases
WHERE username = $1
GROUP BY item
`

type ListInventoryRow struct {
	Item     string
	Quantity int64
}

func (q *Queries) ListInventory(ctx context.Context, username string) ([]ListInventoryRow, error) {
	rows, err := q.db.Query(ctx, listInventory, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryRow
	for rows.Next() {
		var i ListInventoryRow
		if err := rows.Scan(&i.Item, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
